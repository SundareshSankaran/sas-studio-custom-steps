{"creationTimeStamp":"2025-06-10T07:08:47.132Z","modifiedTimeStamp":"2025-06-25T07:14:01.118Z","createdBy":"Remco.Gooijer@sas.com","modifiedBy":"Remco.Gooijer@sas.com","name":"Fork Wait.step","displayName":"Fork Wait.step","localDisplayName":"Fork Wait.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","uri":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","uri":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","uri":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","uri":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31"},{"method":"POST","rel":"copy","href":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31/copy","uri":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31/copy","responseType":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","uri":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","uri":"/dataFlows/steps/882f997c-692e-4bc5-8069-504423ce9c31","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[{"name":"Fork_1","displayName":"Fork_1","localDisplayName":"Fork_1","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"},{"name":"Fork_2","displayName":"Fork_2","localDisplayName":"Fork_2","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"},{"name":"Fork_3","displayName":"Fork_3","localDisplayName":"Fork_3","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"},{"name":"Fork_4","displayName":"Fork_4","localDisplayName":"Fork_4","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"},{"name":"Fork_5","displayName":"Fork_5","localDisplayName":"Fork_5","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"},{"name":"Fork_6","displayName":"Fork_6","localDisplayName":"Fork_6","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"},{"name":"Fork_7","displayName":"Fork_7","localDisplayName":"Fork_7","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"},{"name":"Fork_8","displayName":"Fork_8","localDisplayName":"Fork_8","minEntries":0,"maxEntries":1,"defaultEntries":0,"type":"table"}],"outputPorts":[{"name":"_output","displayName":"_output","localDisplayName":"_output","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table","supportsView":false,"requiresStructure":false}]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"page1\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Fork Wait Properties\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"abort_on_exception\",\n\t\t\t\t\t\"type\": \"checkbox\",\n\t\t\t\t\t\"label\": \"Abort on exception\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_1\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 1:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_2\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 2:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_3\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 3:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_4\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 4:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_5\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 5:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_6\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 6:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_7\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 7:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Fork_8\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Fork wait input table 8:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_output\",\n\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\"label\": \"Output table label:\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page2\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Fork wait custom step\\n===============\\n\\nThis custom step waits for all attached and started 'Fork Run' processes. \\n\\nThe maximum number of attached processes is 8.\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section1\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Change log\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text2\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"* Version 1.0 (25JUN2025)\\n- First version\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"abort_on_exception\": false,\n\t\t\"Fork_1\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"Fork_2\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"Fork_3\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"Fork_4\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"Fork_5\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"Fork_6\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"Fork_7\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"Fork_8\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"_output\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t}\n\t}\n}","templates":{"SAS":"/* options mprint mlogic symbolgen source notes; */\n\n/*\n\tThe maximum number of tables attached to this custom step.\n*/\n%let max_input_count = 8;\n\n/*\n\tThe actual number of input tables attached to the custom step.\n*/\n%let input_count=0;\n\n/*\n\tContains all input tables, separated by a '|' symbol.\n*/\n%let input_string=;\n\n/*\n\tDefault the value to 1/true.\n\tUsed and set by the macros validateInputTables and getInputCount.\n*/\n%let validation_result = 1;\n\n/*\n\tDefine the viyaHost variable, to be used by the REST API call.\t\n*/\ndata _null_; \n\tcall symputx('viyaHost', kreverse(ksubstr(ksubstr(kreverse(\"&_BASEURL.\"), 2), kfind(ksubstr(kreverse(\"&_BASEURL.\"), 2), '/') + 1)));\nrun;\n\n/*\n\tCreate the output table\n*/\ndata &_output;\n\tattrib id length=$36.;\n\tattrib job_name length=$128.;\n\tattrib state length=$32.;\n\tattrib start_dttm length=8 format=datetime22.3;\n\tattrib end_dttm length=8 format=datetime22.3;\n\tstop;\nrun;\n\n/*\n\tCopy the content of the validated input table to the output table.\n\tNote that only non-existing rows are added to the output table.\n*/\n%macro copyInputContent\n(\n\tinputTable\n);\n\t\n\t/*\n\t\tCreate a copy of the output table. You can't use, in case of SAS dataset usage, a table as \n\t\tinput and output at the same time.\n\t*/\n\tdata work._temp;\n\t\tset\n\t\t\t&_output;\n\trun;\n\n\t/*\n\t\tInsert rows not already in the custom step's output table.\n\t*/\n\tproc sql;\n\t\tinsert into &_output\n\t\t(\n\t\t\tid,\n\t\t\tjob_name,\n\t\t\tstate,\n\t\t\tstart_dttm\n\t\t)\n\t\tselect\n\t\t\tt1.id,\n\t\t\tt1.job_name,\n\t\t\tt1.state,\n\t\t\tt1.start_dttm\n\t\tfrom \n\t\t\t&inputTable as t1 left outer join work._temp t2 on t1.id = t2.id\n\t\twhere\n\t\t\tt2.id is null;\t\t\t\n\tquit;\n%mend;\n\n/*\n\tThis macro does the following:\t\n\t- Count the number of tables attached to the custom step.\n\t- Create a '|' separated string with all attached physical table names, to be used by the validateInputTables macro.\n*/\n%macro getInputCount;\n\t%let index = 1;\n\t%do %while (&index le &max_input_count);\n\t\t%if %symexist(Fork_&index) %then %do;\n\t\t\t%let input_count = %eval(&input_count + 1);\n\t\t\t%let input_string = &input_string|%sysfunc(strip(&&Fork_&index));\n\t\t%end;\n\t\t%let index = %eval(&index + 1);\n\t%end;\n\t/*\n\t\tRemove the first '|' character from the input string.\n\t\tNote that this is only valid with more than 0 input tables.\n\n\t\tIn case we have 0 input tables, we set the set the 'validation_result'\n\t\tmacro variable to 0. This will cause the custom step to abort.\n\t*/\n\t%if &input_count gt 0 %then %do;\n\t\t%let input_string = %sysfunc(substr(&input_string, 2));\n\t%end;\n\t%else %do;\n\t\t%let validation_result = 0;\n\t%end;\n%mend;\n%getInputCount;\n\n%put NOTE: Number of attached processes/tables: &input_count;\n%put NOTE: Input string: &input_string;\n%put NOTE: getInputCount validation result: &validation_result;\n\n/*\n\tValidate the input tables for the existance of the four columns.\n*/\n%macro validateInputTables;\n\n\t%let index = 1;\n\t/*\n\t\tAs long as there is a table and the validation for a table checks-out, continue.\n\t\tNote that in case the macro getInputCount return validation_result equals 0, the macro will abend.\n\t*/\n\t%do %while (%scan(&input_string, &index, '|') ne %str() and &validation_result);\n\t\t%let table = %scan(&input_string, &index, '|');\n\t\t%put NOTE: Validating table: &table;\n\t\t/*\n\t\t\tCheck for the columns:\n\t\t\t1. ID\n\t\t\t\tThe ID of the job execution id.\n\t\t\t2. JOB_NAME\n\t\t\t\tThe name of the job execution.\n\t\t\t3. STATE\n\t\t\t\tThe initial status of the job execution.\n\t\t\t4. START_DTTM\n\t\t\t\tThe date and time the job execution started.\n\t\t*/\n\t\t%let ds = %sysfunc(open(&table));\n\t\t%if &ds > 0 %then %do;\n\t\t\t%let dsID = %sysfunc(varnum(&ds, ID));\n\t\t\t%let dsNAME = %sysfunc(varnum(&ds, JOB_NAME));\n\t\t\t%let dsSTATUS = %sysfunc(varnum(&ds, STATE));\n\t\t\t%let dsSTARTDT = %sysfunc(varnum(&ds, start_dttm));\n\n\t\t\t%if &dsID and &dsNAME and &dsSTATUS and &dsSTARTDT %then %do;\n\t\t\t\t%let validation_result = 1;\n\t\t\t\t%put NOTE: Validation for table &table succeeded.;\n\t\t\t\t/*\n\t\t\t\t\tThe input table checks out. \n\t\t\t\t\tNow copy the content of the input table to the output table so that\n\t\t\t\t\tit can be maintained there.\n\t\t\t\t*/\n\t\t\t\t%copyInputContent\n\t\t\t\t(\n\t\t\t\t\tinputTable= &table\n\t\t\t\t);\n\t\t\t%end;\n\t\t\t%else %do;\n\t\t\t\t%let validation_result = 0;\n\t\t\t\t%put NOTE: Validation for table &table failed.;\n\t\t\t%end;\n\t\t%end;\n\t\t%else %do;\n\t\t\t%let validation_result = 0;\n\t\t\t%put ERROR: Unable to open table &table for validation.;\t\n\t\t%end;\n\t\t\n\t\t%let rc = %sysfunc(close(&ds));\n\n\t\t%let index = %eval(&index + 1);\n\t%end;\n%mend;\n%validateInputTables;\n\n%put NOTE: Validation result: &validation_result;\n\n/*\n\t\n*/\n%macro update_status\n(\n\tId=\n);\n\t/*\n\t\tThis process only makes sense when the output table exists.\n\t*/\n\t%if %sysfunc(exist(&_output, data)) %then %do;\n\t\t/*\n\t\t\tSetup and execute the HTTP request.\n\t\t*/\n\t\tfilename response temp;\n\t\tproc http\n\t\t\turl=\"&viyahost./jobExecution/jobs/&Id\"\n\t\t\tout=response\n\t\t\tmethod=\"get\"\n\t\t\t\toauth_bearer = sas_services;\n\t\t\theaders\n\t\t\t\t'Accept'='application/json';\n\t\trun;\n\n\t\t%if %sysfunc(fexist(response)) %then %do;\n\t\t\tlibname status json fileref=response;\n\t\t\t/*\n\t\t\t\tUpdate the output table with the values from the REST API.\n\t\t\t\tNote that the root table will always contain one row.\n\t\t\t*/\n\t\t\tproc sql noprint;\n\t\t\t\tupdate \n\t\t\t\t\t&_output\n\t\t\t\tset \t\n\t\t\t\t\tstate = \n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tselect \n\t\t\t\t\t\t\t\tkstrip(state) \n\t\t\t\t\t\t\tfrom \n\t\t\t\t\t\t\t\tstatus.root\n\t\t\t\t\t\t),\n\t\t\t\t\tend_dttm = \n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tselect \n\t\t\t\t\t\t\t\tinput(modifiedTimeStamp, E8601DZ.)\n\t\t\t\t\t\t\tfrom\n\t\t\t\t\t\t\t\tstatus.root\n\t\t\t\t\t\t)\n\t\t\t\twhere\n\t\t\t\t\tid = \"&id\";\n\t\t\tquit;\n\t\t\tlibname status clear;\n\t\t%end;\n\t\t%else %do;\n\t\t\t/*\n\t\t\t\tNo abort, might be a hick-up...\n\t\t\t*/\n\t\t\t%put ERROR: Unable to update the status table. No response file encountered.;\n\t\t%end;\n\t%end;\n\t%else %do;\n\t\t%put ERROR: The status table, &_output, does not exist.;\n\t\t%abort exit;\n\t%end;\n%mend;\n\n%macro check_for_completion;\n\t/*\n\t\tUpdate for all processes the status and determain if all processes have finished.\n\t*/\n\t%if %sysfunc(exist(&_output, data)) %then %do;\n\t\t%let still_running = -1;\n\t\t%let wait_cycles = 0;\n\t\t%do %while (&still_running ne 0);\n\t\t\t/*\n\t\t\t\tUpdate the status for all running jobs.\n\t\t\t*/\n\t\t\tdata _null_;\n\t\t\t\tset\n\t\t\t\t\t&_output\n\t\t\t\t\t(\n\t\t\t\t\t\twhere=(kupcase(state) = 'RUNNING')\n\t\t\t\t\t);\n\t\t\t\t\t\tcall execute\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tcats\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t'%update_status(Id= %STR(',\n\t\t\t\t\t\t\t\tkSTRIP(id),\n\t\t\t\t\t\t\t\t'))'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\trun;\n\t\n\t\t\t/*\n\t\t\t\tCount the number of jobs that are running.\n\t\t\t*/\n\t\t\tproc sql noprint;\n\t\t\t\tselect \n\t\t\t\t\tcount(*) into :still_running TRIMMED\n\t\t\t\tfrom \n\t\t\t\t\t&_output \n\t\t\t\twhere \n\t\t\t\t\tkupcase(state) = 'RUNNING';\n\t\t\tquit;\n\t\t\t%put NOTE: Number of jobs that are running: &still_running;\n\t\n\t\t\t/*\n\t\t\t\tSleep for one second before checking for completion again.\n\t\t\t*/\n\t\t\tdata _null_;\n\t\t\t\tslept = sleep(1, 1);\n\t\t\trun;\n\t\t\t%let wait_cycles = %eval(&wait_cycles + 1);\n\t\t%end;\n\t\t%put NOTE: Total number of wait cycles of 1 second: &wait_cycles;\n\t%end;\n\t%else %do;\n\t\t%put ERROR: The status table, &_output, does not exist.;\n\t\t%abort exit;\n\t%end;\n%mend;\n\n/*\n\tThe input tables have been verified, the contents has been copied.\n\tThe custom step continues with waiting for all processes to be finished. (= NOT 'Running')\n*/\n%macro main;\n\t%if &validation_result %then %do;\n\t\t%check_for_completion;\n\t%end;\n\t%else %do;\n\t\t%put ERROR: Input validation failed. Aborting process.;\n\t\t%abort exit;\n\t%end;\n%mend;\n%main;\n\n%macro abort_on_failure;\n\t%let exception = 0;\n\t%if &abort_on_exception eq 1 %then %do;\n\t\tproc sql noprint;\n\t\t\tselect \n\t\t\t\tcount(*) into :exception trimmed\n\t\t\tfrom \n\t\t\t\t&_output \n\t\t\twhere \n\t\t\t\tkupcase(state) ne 'COMPLETED';\n\t\tquit;\n\t\t\t\n\t\t%if &exception ne 0 %then %do;\n\t\t\t%put ERROR: &exception exception(s) encountered. Aborting process.;\n\t\t\t%abort exit;\n\t\t%end;\n\t\t%else %do;\n\t\t\t%put NOTE: No exceptions encountered. Continuing with the rest of the flow.;\n\t\t%end;\n\t%end;\n%mend;\n%abort_on_failure;\n\n/*\n\tRemove not needed macro variables.\n*/\n%symdel max_input_count /nowarn;\n%symdel input_count /nowarn;\n%symdel input_string /nowarn;\n%symdel validation_result /nowarn;\n\n/*\n\tRemove not needed macros\n*/\n%sysmacdelete abort_on_failure /nowarn;\n%sysmacdelete main /nowarn;\n%sysmacdelete check_for_completion /nowarn;\n%sysmacdelete update_status /nowarn;\n%sysmacdelete validateInputTables /nowarn;\n%sysmacdelete getInputCount /nowarn;\n%sysmacdelete copyInputContent /nowarn;"}}