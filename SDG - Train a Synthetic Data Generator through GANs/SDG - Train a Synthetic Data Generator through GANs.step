{"creationTimeStamp":"2025-02-17T19:04:59.579Z","modifiedTimeStamp":"2025-02-17T19:06:01.125Z","createdBy":"sinsrn","modifiedBy":"sinsrn","name":"SDG - Train a Synthetic Data Generator through GANs.step","displayName":"SDG - Train a Synthetic Data Generator through GANs.step","localDisplayName":"SDG - Train a Synthetic Data Generator through GANs.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","uri":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","uri":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","uri":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","uri":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407"},{"method":"POST","rel":"copy","href":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407/copy","uri":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407/copy","responseType":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","uri":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","uri":"/dataFlows/steps/c7922485-826a-4186-a89f-06195c59a407","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[{"name":"inputtable1","displayName":"inputtable1","localDisplayName":"inputtable1","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table"}],"outputPorts":[{"name":"outputtable2","displayName":"outputtable2","localDisplayName":"outputtable2","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table","supportsView":false,"requiresStructure":false},{"name":"outputtable1","displayName":"outputtable1","localDisplayName":"outputtable1","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table","supportsView":false,"requiresStructure":false}]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"param\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Parameters\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section1\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Input parameters\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"inputtable1\",\n\t\t\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\t\t\"label\": \"Input table:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text2\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Connect a SAS Cloud Analytics Services (CAS) table to the input port attached to this step.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"intervalVars\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select interval candidate variables (min 1) :\",\n\t\t\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"table\": \"inputtable1\",\n\t\t\t\t\t\t\t\"include\": null\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"nominalVars\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select nominal candidate variables:\",\n\t\t\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"table\": \"inputtable1\",\n\t\t\t\t\t\t\t\"include\": null\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section2\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Output specification\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text1_1\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Attach CAS tables to the two output ports of this step.  The second port (for sample output records) is optional.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"outputtable2\",\n\t\t\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\t\t\"label\": \"Desired model binary name:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Note: the model table gets persisted in the given caslib as a sashdat by default.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"outputtable1\",\n\t\t\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\t\t\"label\": \"Sample output table:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"PUBLIC.__TEMP_SDGGAN_SAMPLES\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"numSamples\",\n\t\t\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\t\t\"label\": \"Provide number of samples:\",\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"advanced\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Configuration\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"aeEpochs\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Enter # of epochs for the Autoencoder optimizer:\",\n\t\t\t\t\t\"placeholder\": \"1\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"excludemin\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"ganEpochs\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Enter # of epochs for the GAN optimizer:\",\n\t\t\t\t\t\"placeholder\": \"1\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"excludemin\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"miniBatchSize\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Provide minibatch size:\",\n\t\t\t\t\t\"placeholder\": \"60\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"gpuEnabled\",\n\t\t\t\t\t\"type\": \"checkbox\",\n\t\t\t\t\t\"label\": \"Enable GPU\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"numDevices\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Specify GPU device ID (max 1):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"$gpuEnabled\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page2\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text_description\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Train a Synthetic Data Generator through Generative Adversarial Networks (GANs)\\n========================================================\\n\\nThis custom step helps you train a model through Generative Adversarial Networks (GANs) using underlying distributions and correlations learnt from an existing dataset.  This step results in a model binary, known as an astore, which can be used in a scoring process.\\n\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"about_parameters\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Parameters\",\n\t\t\t\t\t\"open\": false,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"parameters_text\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"This custom step runs on data loaded to a SAS Cloud Analytics Services (CAS) library (known as a caslib). Ensure you are connected to CAS before running this step.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"parameters_input\",\n\t\t\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\t\t\"label\": \"Input Parameters\",\n\t\t\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"id\": \"input_parameters_text\",\n\t\t\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"1. An input dataset referring to an in-memory CAS table, which serves as the training data - connect this to the input port of this step.\\n\\n2. Provide both interval (min=1) and nominal variables to be used for training the model. \\n\\n\",\n\t\t\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"parameters_config\",\n\t\t\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\t\t\"label\": \"Configuration\",\n\t\t\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"id\": \"input_parameters_text_1\",\n\t\t\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"1. Number of epochs for autoencoder optimizer (numeric field, default 1): change as required.\\n\\n2. Number of epochs for the GAN optimizer (numeric field, default 1): change as required\\n\\n3. Minibatch size (default 60): change as required\\n\\n4. Enable GPU (check box, deselected by default): check this option if you wish to use GPUs to train.\\n\\n5. GPU device ID (text field, dependent on GPU enabled): enter a value only if you want to specify a device ID different from the default.  Note that the tabularGanTrain action is set to use a max of 1 GPU.\",\n\t\t\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"parameters_output_specs\",\n\t\t\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\t\t\"label\": \"Output specification\",\n\t\t\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"id\": \"output_parameters_text\",\n\t\t\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"1. Provide number of sample observations to generate.\\n\\n2. Attach a table to the output port for Desired Model Binary, which will hold the astore table. (Note: the astore is a binary table. Do not attempt to open it within SAS Studio as it won't be readable.)\\n\\n3. Attach a table to the output port for Output Data, which contains sample generated observations for review.\\n\",\n\t\t\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"about_runtimecontrol\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Run-time Control\",\n\t\t\t\t\t\"open\": false,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"runtimecontrol_text\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Note: Run-time control is optional.  You may choose whether to execute the main code of this step or not, based on upstream conditions set by earlier SAS programs.  This includes nodes run prior to this custom step earlier in a SAS Studio Flow, or a previous program in the same session.\\n\\nRefer this blog (https://communities.sas.com/t5/SAS-Communities-Library/Switch-on-switch-off-run-time-control-of-SAS-Studio-Custom-Steps/ta-p/885526) for more details on the concept.\\n\\nThe following macro variable,\\n\\n_tsdg_run_trigger\\n\\nwill initialize with a value of 1 by default, indicating an \\\"enabled\\\" status and allowing the custom step to run.\\n\\nIf you wish to control execution of this custom step, include code in an upstream SAS program to set this variable to 0.  This \\\"disables\\\" execution of the custom step.\\n\\nTo \\\"disable\\\" this step, run the following code upstream:\\n\\n%global _tsdg_run_trigger;\\n%let _tsdg_run_trigger =0;\\n\\nTo \\\"enable\\\" this step again, run the following (it's assumed that this has already been set as a global variable):\\n\\n%let _tsdg_run_trigger =1;\\n\\nIMPORTANT: Be aware that disabling this step means that none of its main execution code will run, and any  downstream code which was dependent on this code may fail.  Change this setting only if it aligns with the objective of your SAS Studio program.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"about_documentation\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Documentation\",\n\t\t\t\t\t\"open\": false,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"documentation_text\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"1. The proc tabularGAN procedure is documented here: https://go.documentation.sas.com/doc/en/vwbcasml/v_001/vwbcasml_tabulargan_toc.htm\\n\\n2. The generativeAdversarialNet.tabularGanTrain action (a CASL-oriented interface for the algorithm) is documented here: https://documentation.sas.com/?cdcId=pgmsascdc&cdcVersion=default&docsetId=casactml&docsetTarget=cas-generativeadversarialnet-tabulargantrain.htm\\n\\n3. The proc gmm procedure is documented here: https://go.documentation.sas.com/doc/en/sasstudiocdc/v_056/pgmsascdc/casml/casml_gmm_toc.htm\\n\\n4. The nonparametricBayes.gmm action (a CASL-oriented interface for the algorithm) is documented here: https://go.documentation.sas.com/doc/en/pgmsascdc/default/casactml/casactml_nonparametricbayes_details01.htm\\n\\n5. This SAS Communities article: https://communities.sas.com/t5/SAS-Communities-Library/Switch-on-switch-off-run-time-control-of-SAS-Studio-Custom-Steps/ta-p/885526 referred to earlier suggests an approach through which execution of this custom step is controlled during run time.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"change_log_text\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Version: 2.1  (17FEB2025)\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"contact_text\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Created/contact: \\n\\n- Sundaresh Sankaran (sundaresh.sankaran@sas.com)\\n- Brett Wujek (brett.wujek@sas.com)\\n- Reza Nazari (reza.nazari@sas.com) \\n- Ruiwen Zhang (ruiwen.zhang@sas.com) \\n- Lorne Rothman (lorne.rothman@sas.com)\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"inputtable1\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"intervalVars\": [],\n\t\t\"nominalVars\": [],\n\t\t\"outputtable2\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"outputtable1\": {\n\t\t\t\"library\": \"PUBLIC\",\n\t\t\t\"table\": \"__TEMP_SDGGAN_SAMPLES\"\n\t\t},\n\t\t\"numSamples\": 20,\n\t\t\"aeEpochs\": 1,\n\t\t\"ganEpochs\": 1,\n\t\t\"miniBatchSize\": 60,\n\t\t\"gpuEnabled\": false,\n\t\t\"numDevices\": 0\n\t},\n\t\"promptHierarchies\": [],\n\t\"columnExclusions\": [\n\t\t[\n\t\t\t\"nominalVars\",\n\t\t\t\"intervalVars\"\n\t\t]\n\t]\n}","templates":{"SAS":"/* SAS templated code goes here */\n\n/* -------------------------------------------------------------------------------------------* \n   Synthetic Data Generation (SDG) - Train a Synthetic Data Generator through GANs\n\n   v 2.1 (17FEB2025)\n\n   This program train a model through Generative Adversarial Networks (GANs) using underlying \n   distributions and correlations learnt from an existing dataset.  \n   This step results in a model binary, known as an astore, which can be used in a scoring process. \n   Please modify requisite macro variables (hint: use the debug section as a reference) to run this \n   through other interfaces, such as a SAS Program editor or the SAS extension for Visual Studio Code.\n\n   Sundaresh Sankaran (sundaresh.sankaran@sas.com|sundaresh.sankaran@gmail.com)\n*-------------------------------------------------------------------------------------------- */\n\n\n/*-----------------------------------------------------------------------------------------*\n   START MACRO DEFINITIONS.\n*------------------------------------------------------------------------------------------*/\n\n/* -------------------------------------------------------------------------------------------* \n   Macro to initialize a run-time trigger global macro variable to run SAS Studio Custom Steps. \n   A value of 1 (the default) enables this custom step to run.  A value of 0 (provided by \n   upstream code) sets this to disabled.\n\n   Input:\n   1. triggerName: The name of the runtime trigger you wish to create. Ensure you provide a \n      unique value to this parameter since it will be declared as a global variable.\n\n   Output:\n   2. &triggerName : A global variable which takes the name provided to triggerName.\n*-------------------------------------------------------------------------------------------- */\n\n%macro _create_runtime_trigger(triggerName);\n\n   %global &triggerName.;\n\n   %if %sysevalf(%superq(&triggerName.)=, boolean)  %then %do;\n  \n      %put NOTE: Trigger macro variable &triggerName. does not exist. Creating it now.;\n      %let &triggerName.=1;\n\n   %end;\n\n%mend _create_runtime_trigger;\n\n/* -----------------------------------------------------------------------------------------* \n   Macro to create an error flag for capture during code execution.\n\n   Input:\n      1. errorFlagName: The name of the error flag you wish to create. Ensure you provide a \n         unique value to this parameter since it will be declared as a global variable.\n      2. errorFlagDesc: A description to add to the error flag.\n\n    Output:\n      1. &errorFlagName : A global variable which takes the name provided to errorFlagName.\n      2. &errorFlagDesc : A global variable which takes the name provided to errorFlagDesc.\n*------------------------------------------------------------------------------------------ */\n\n%macro _create_error_flag(errorFlagName, errorFlagDesc);\n\n   %global &errorFlagName.;\n   %let  &errorFlagName.=0;\n   %global &errorFlagDesc.;\n\n%mend _create_error_flag;\n\n/*-----------------------------------------------------------------------------------------*\n   Macro to capture indicator and UUIDof any currently active CAS session.\n   UUID is not expensive and can be used in future to consider graceful reconnect.\n\n   Input:\n   1. errorFlagName: name of an error flag that gets populated in case the connection is \n                     not active. Provide this value in quotes when executing the macro.\n                     Define this as a global macro variable in order to use downstream.\n   2. errorFlagDesc: Name of a macro variable which can hold a descriptive message output\n                     from the check.\n                     \n   Output:\n   1. Informational note as required. We explicitly don't provide an error note since \n      there is an easy recourse(of being able to connect to CAS)\n   2. UUID of the session: macro variable which gets created if a session exists.\n   3. errorFlagName: populated\n   4. errorFlagDesc: populated\n*------------------------------------------------------------------------------------------*/\n\n%macro _env_cas_checkSession(errorFlagName, errorFlagDesc);\n\n    %if %sysfunc(symexist(_current_uuid_)) %then %do;\n       %symdel _current_uuid_;\n    %end;\n    %if %sysfunc(symexist(_SESSREF_)) %then %do;\n      %let casSessionExists= %sysfunc(sessfound(&_SESSREF_.));\n      %if &casSessionExists.=1 %then %do;\n         %global _current_uuid_;\n         %let _current_uuid_=;   \n         proc cas;\n            session.sessionId result = sessresults;\n            call symputx(\"_current_uuid_\", sessresults[1]);\n         quit;\n         %put NOTE: A CAS session &_SESSREF_. is currently active with UUID &_current_uuid_. ;\n         data _null_;\n            call symputx(&errorFlagName., 0);\n            call symput(&errorFlagDesc., \"CAS session is active.\");\n         run;\n      %end;\n      %else %do;\n         %put NOTE: Unable to find a currently active CAS session. Reconnect or connect to a CAS session upstream. ;\n         data _null_;\n            call symputx(&errorFlagName., 1);\n            call symput(&errorFlagDesc., \"Unable to find a currently active CAS session. Reconnect or connect to a CAS session upstream.\");\n        run;\n      %end;\n   %end;\n   %else %do;\n      %put NOTE: No active CAS session ;\n      data _null_;\n        call symputx(&errorFlagName., 1);\n        call symput(&errorFlagDesc., \"No active CAS session. Connect to a CAS session upstream.\");\n      run;\n   %end;\n\n%mend _env_cas_checkSession;   \n\n/*-----------------------------------------------------------------------------------------*\n   Macro to check if a given libref belongs to a SAS or CAS engine.\n\n   Input:\n   1. sasCasLibref: a libref to be checked. Do not quote.\n   2. tableEngine: a flag to hold the table Engine value.\n   3. errorFlagName: a flag to populate an error code with.\n   4. errorFlagDesc: a flag to describe the error if one occurs.\n   5. sessionExists: an indicator (1) whether an active CAS session exists.  If not(0),\n                     it will be created.\n                     \n   Output:\n   1. tableEngine: populated with SAS or CAS\n   2. errorFlagName: populated with 1 if an error and 0 if not\n   3. errorFlagDesc: populated in case of an error\n*------------------------------------------------------------------------------------------*/\n\n%macro _sas_or_cas(sasCasLibref, tableEngine, errorFlagName, errorFlagDesc, sessionExists);\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ ;\n      caslib _ALL_ assign;\n   %end;\n\n    proc sql noprint;\n        select distinct Engine into:&&tableEngine. from dictionary.libnames where libname = upcase(\"&sasCasLibref.\");\n    quit;\n\n    %put \"&&&tableEngine.\";\n\n    %if %sysfunc(compress(\"&&&tableEngine.\")) = \"V9\" %THEN %DO;\n        data _null_;\n            call symput(\"&tableEngine.\",\"SAS\");\n            call symputx(\"&errorFlagName.\",0);\n            call symput(\"&errorFlagDesc.\",\"\");\n        run;\n    %end;\n    %else %if %sysfunc(compress(\"&&&tableEngine.\")) = \"CAS\" %THEN %DO;\n        data _null_;\n            call symputx(\"&errorFlagName.\",0);\n            call symput(\"&errorFlagDesc.\",\"\");\n        run;\n    %END;\n    %else %do;\n        data _null_;\n            call symputx(\"&errorFlagName.\",1);\n            call symput(\"&errorFlagDesc.\",\"Unable to associate libref with either SAS or CAS. Check the input libref provided.\");\n        run;\n    %end;\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ terminate;\n   %end;\n    \n%mend _sas_or_cas;\n\n/*-----------------------------------------------------------------------------------------*\n   Macro to check if an in-memory table exists.\n\n   Input:\n   1. tableName: name of the in-memory table\n   2. tableLib: caslib backing the in-memory table\n   3. sessionExists: an indicator (1) whether an active CAS session exists.  If not(0),\n                     it will be created.\n                     \n   Output:\n   1. tableExists: populated with 0 if does not exist, 1 if exists with local scope, \n                   2 if exists with global scope\n\n*------------------------------------------------------------------------------------------*/   \n\n%macro _cas_table_exists(tableName, tableLib, sessionExists, tableExists);\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ ;\n      caslib _ALL_ assign;\n   %end;\n\n   proc cas;\n      table.tableExists result = rc /\n         name=\"&tableName.\",\n         caslib=\"&tableLib.\"\n      ;\n      call symputx(\"&tableExists.\",rc.exists);\n   quit;\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ terminate;\n   %end;\n    \n%mend _cas_table_exists;\n\n\n/*--------------------------------------------------------------------------------------*\n   Macro to execute string substitution for \"GPU Devices\" in case the user enables GPU & \n   specifies a GPU device ID. \n\n   Note : For those interested, a little dated but insightful SAS Global Forum paper on \n   the best way to evaluate if a macro variable is blank (as used below), provided here:\n   http://support.sas.com/resources/papers/proceedings09/022-2009.pdf \n*---------------------------------------------------------------------------------------*/\n\n%macro _gpu_status_string_substitute;\n   %global deviceArgumentString;\n   %if &gpuEnabled.=0 %then %do;\n      %let deviceArgumentString=;\n   %end;\n   %else %do;\n      %if %sysevalf(%superq(numDevices)=,boolean) %then %do;\n         data _null_;\n            call symput(\"deviceArgumentString\",\"useGPU (device=0)\");\n         run;\n      %end;\n      %else %do;\n         data _null_;\n            call symput(\"deviceArgumentString\",\"useGPU (device=&numDevices.)\");\n         run;\n      %end;\n   %end;\n\n%mend _gpu_status_string_substitute;\n\n/* -----------------------------------------------------------------------------------------* \n   This macro creates a global macro variable called _usr_nameCaslib\n   that contains the caslib name (aka. caslib-reference-name) associated with the libname \n   and assumes that the libname is using the CAS engine.\n\n   As sysvalue has a length of 1024 chars, we use the trimmed option in proc sql\n   to remove leading and trailing blanks in the caslib name.\n*------------------------------------------------------------------------------------------ */\n\n%macro _usr_getNameCaslib(_usr_LibrefUsingCasEngine); \n\n   %global _usr_nameCaslib;\n   %let _usr_nameCaslib=;\n\n   proc sql noprint;\n      select sysvalue into :_usr_nameCaslib trimmed from dictionary.libnames\n      where libname = upcase(\"&_usr_LibrefUsingCasEngine.\") and upcase(sysname)=\"CASLIB\";\n   quit;\n\n%mend _usr_getNameCaslib;\n\n\n/* -----------------------------------------------------------------------------------------* \n   This macro loops through all selected input interval variables and creates centroid tables\n   for them.\n*------------------------------------------------------------------------------------------ */\n%macro _tsdg_create_centroids_table;\n\n  \n     /* Loop over all variables that need centroids generation */\n   %do i=1 %to &intervalVars_count.;\n\n      %let name&i. = %scan(%nrquote(&blankSeparatedIntervalVars.), &i., %str(\" \"));\n     \n     /* Call PROC GMM to cluster each variable */\n      proc gmm\n         data=&inputtable1.\n         seed=42\n         maxClusters=10\n         alpha=1\n         inference=VB (maxVbIter=30 covariance=diagonal threshold=0.01);\n         input &&name&i..;\n         ods select ClusterInfo;\n         ods output ClusterInfo = work.outinfo&i;\n      run;\n\n     /* Save variable name, weights, mean,     */\n     /* and standard deviation of each cluster */\n      data  work.outinfo&i;\n        length varname $32.;\n         varname = \"&&name&i.\";\n         set  work.outinfo&i.(rename=(&&name&i.._Mean=Mean &&name&i.._Variance=Var));\n         /* Calculate standard deviation from variance*/\n         std = sqrt(Var);\n         drop Var;\n      run;\n\n     /* Construct centroids table from saved weights */\n      %if &i.=1 %then %do;\n\n         data work._centroids;\n            set work.outinfo&i.;\n         run;\n         proc datasets lib=work;\n            delete outinfo&i. ;\n         run;\n\n      %end;\n      %else %do;\n         data work._centroids;\n            set work._centroids work.outinfo&i;\n         run;\n\n         proc datasets lib=work;\n            delete outinfo&i. ;\n         run;\n\n      %end;\n   %end;\n\n %mend _tsdg_create_centroids_table;\n\n\n/*-----------------------------------------------------------------------------------------*\n   EXECUTION CODE MACRO - tsdg stands for train synthetic data generator\n*------------------------------------------------------------------------------------------*/\n\n%macro _tsdg_execution_code;\n\n/*-----------------------------------------------------------------------------------------*\n   Create an error flag. \n*------------------------------------------------------------------------------------------*/\n\n   %_create_error_flag(_tsdg_error_flag, _tsdg_error_desc);\n\n/*-----------------------------------------------------------------------------------------*\n   Check if an active CAS session exists. \n*------------------------------------------------------------------------------------------*/\n\n   %_env_cas_checkSession(\"_tsdg_error_flag\", \"_tsdg_error_desc\");\n\n/*-----------------------------------------------------------------------------------------*\n   Check Input table libref to ensure it points to a valid caslib.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n\n      %global _sas_or_cas_inp;\n      %_sas_or_cas(&inputtable1_lib., _sas_or_cas_inp, _tsdg_error_flag, _tsdg_error_desc, 1 );\n      %put NOTE: Input table engine is &_sas_or_cas_inp. ;\n      %if %sysfunc(compress(\"&_sas_or_cas_inp.\"))=\"CAS\" %then %do;\n         %put NOTE: Input table belongs to a CAS libref.;\n      %end;\n      %else %do;\n         data _null_;\n            call symputx(\"_tsdg_error_flag\", 60);\n            call symput(\"_tsdg_error_desc\",\"The input table should be associated with a CAS engine.\");\n         run;\n      %end;\n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Check output table 2 (model) table libref to ensure it points to a valid caslib.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n\n      %global _sas_or_cas_op2;\n      %_sas_or_cas(&outputtable2_lib., _sas_or_cas_op2, _tsdg_error_flag, _tsdg_error_desc, 1 );\n      %put NOTE: Model table engine is &_sas_or_cas_op2. ;\n      %if %sysfunc(compress(\"&_sas_or_cas_op2.\"))=\"CAS\" %then %do;\n         %put NOTE: Model table belongs to a CAS libref.;\n      %end;\n      %else %do;\n         data _null_;\n            call symputx(\"_tsdg_error_flag\", 60);\n            call symput(\"_tsdg_error_desc\",\"The model table should be associated with a CAS engine.\");\n         run;\n      %end;\n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Check Sample output table libref to ensure it points to a valid caslib.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n      %if %sysevalf(%superq(outputtable1_lib)=,boolean)  %then %do;\n         %put ERROR: No sample table library provided. Please attach a CAS table to the outputtable1 port.;\n         data _null_;\n            call symput(\"_tsdg_error_flag\",1);\n            call symput(\"_tsdg_error_desc\",\"No sample table library provided. Please attach a CAS table to the outputtable1 port.\");\n         run;\n      %end;\n      %else %do;\n         %global _sas_or_cas_op;\n         %_sas_or_cas(&outputtable1_lib., _sas_or_cas_op, _tsdg_error_flag, _tsdg_error_desc, 1 );\n         %put NOTE: Sample output table engine is &_sas_or_cas_op. ;\n         %if %sysfunc(compress(\"&_sas_or_cas_op.\"))=\"CAS\" %then %do;\n            %put NOTE: Sample output table belongs to a CAS libref.;\n         %end;\n         %else %if %sysfunc(compress(\"&_sas_or_cas_op.\"))=\"SAS\" %then %do;\n            data _null_;\n               call symputx(\"_tsdg_error_flag\", 60);\n               call symput(\"_tsdg_error_desc\",\"The sample table should be associated with a CAS engine.\");\n            run;\n            %put ERROR:&_tsdg_error_desc.;\n         %end;\n      %end;\n   %end;\n\n\n\n/*-----------------------------------------------------------------------------------------*\n   Check if input table exists.\n*------------------------------------------------------------------------------------------*/\n   \n   %global casTableExists;\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n      %_cas_table_exists(&inputTable1_name_base.,&inputTable1_lib.,1,casTableExists);\n      %if &casTableExists.=0 %then %do;\n         data _null_;\n            call symputx(\"_tsdg_error_flag\",1);\n            call symput(\"_tsdg_error_desc\",\"ERROR: The given CAS table does not seem to exist. Please check if it is loaded to CAS.\");\n         run;\n         %put ERROR: The given CAS table does not seem to exist. Please check if it is loaded to CAS.;\n      %end;    \n   %end;\n\n/*--------------------------------------------------------------------------------------*\n   Macro variables to hold the selected interval and nominal input variables.\n*---------------------------------------------------------------------------------------*/\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n      %let blankSeparatedIntervalVars = %_flw_get_column_list(_flw_prefix=intervalVars);\n      %let blankSeparatedNominalVars = %_flw_get_column_list(_flw_prefix=nominalVars);\n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Run the libref check macro in order to obtain the correct Caslib for desired tables.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n\n      %global inputCaslib;\n      %global outputCaslib;\n      %global modelCaslib;\n\n      %_usr_getNameCaslib(&inputtable1_lib.);\n      %let inputCaslib=&_usr_nameCaslib.;\n      %put NOTE: &inputCaslib. is the input caslib.;\n      %let _usr_nameCaslib=;\n\n      %_usr_getNameCaslib(&outputtable1_lib.);\n      %let outputCaslib=&_usr_nameCaslib.;\n      %let _usr_nameCaslib=;\n\n      %_usr_getNameCaslib(&outputtable2_lib.);\n      %let modelCaslib=&_usr_nameCaslib.;\n      %let _usr_nameCaslib=;\n\n   %end;\n\n\n   /* -----------------------------------------------------------------------------------------* \n      Run the _tsdg_create_centroids_table macro to generate the centroids table.\n   *------------------------------------------------------------------------------------------ */\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n      %_tsdg_create_centroids_table;\n\n      data &outputtable2_lib.._centroids;\n         set work._centroids;\n      run;\n\n      proc datasets lib=work;\n         delete _centroids;\n      quit;\n\n   %end;\n\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n\n/*    -----------------------------------------------------------------------------------------*  */\n/*       Execute the gpu_status_string_substitute macro. */\n/*    *------------------------------------------------------------------------------------------ */\n\n      \n      %_gpu_status_string_substitute;\n\n      proc tabulargan\n         data=&inputtable1. \n         seed=123 \n         numSamples=&numSamples. \n         &deviceArgumentString.\n      ;\n         input               &blankSeparatedIntervalVars. /level=interval;\n         input               &blankSeparatedNominalVars./level=nominal;\n         gmm                 centroidsTable=&outputtable2_lib.._centroids;\n         aeoptimization      ADAM numEpochs=&aeEpochs.;\n         ganoptimization     ADAM numEpochs=&ganEpochs.;\n         train               miniBatchSize=&miniBatchSize.;\n         savestate           rstore=&outputtable2.;\n         output              out=&outputtable1.;\n      run;\n\n      data &outputtable1.;      \n         set &outputtable1.;      \n         SYNTHETIC_DATA_FLAG = 1;       \n      run;\n\n   %end;\n\n/* -----------------------------------------------------------------------------------------* \n   Persist score table (astore)\n*------------------------------------------------------------------------------------------ */\n\n   %if &_tsdg_error_flag. = 0 %then %do;\n\n      proc cas;\n\n         /* -----------------------------------------------------------------------------------------* \n            Obtain values from UI and store inside variables\n         *------------------------------------------------------------------------------------------ */\n         input_table_name =symget(\"inputtable1_name_base\");\n         input_table_lib  =symget(\"inputCaslib\");\n         model_table_name =symget(\"outputtable2_name_base\");\n         model_table_lib  =symget(\"modelCaslib\");\n         output_table_name=symget(\"outputtable1_name_base\");\n         output_table_lib =symget(\"outputCaslib\");\n\t\n         table.save /\n            table  ={name = model_table_name, caslib=model_table_lib}\n            name   =model_table_name\n            caslib =model_table_lib\n            replace=True\n         ;\n      quit;\n\n      proc datasets lib=&outputtable2_lib.;\n         delete _centroids;\n      run;\n\n   %end;\n\n%mend _tsdg_execution_code;\n\n/*-----------------------------------------------------------------------------------------*\n   END OF MACROS\n*------------------------------------------------------------------------------------------*/\n\n\n/*-----------------------------------------------------------------------------------------*\n   EXECUTION CODE\n   The execution code is controlled by the trigger variable defined in this custom step. This\n   trigger variable is in an \"enabled\" (value of 1) state by default, but in some cases, as \n   dictated by logic, could be set to a \"disabled\" (value of 0) state.\n*------------------------------------------------------------------------------------------*/\n\n\n\n%_create_runtime_trigger(_tsdg_run_trigger);\n\n%if &_tsdg_run_trigger. = 1 %then %do;\n   %_tsdg_execution_code;\n%end;\n%if &_tsdg_run_trigger. = 0 %then %do;\n   %put NOTE: This step has been disabled.  Nothing to do.;\n%end;\n\n\n/*-----------------------------------------------------------------------------------------*\n   Clean up existing macro variables and macro definitions.\n*------------------------------------------------------------------------------------------*/\n\n%if %symexist(casTableExists) %then %do;\n   %symdel casTableExists;\n%end;\n\n%if %symexist(_sas_or_cas_inp) %then %do;\n   %symdel _sas_or_cas_inp;\n%end;\n\n%if %symexist(_sas_or_cas_op) %then %do;\n   %symdel _sas_or_cas_op;\n%end;\n\n%if %symexist(_sas_or_cas_op2) %then %do;\n   %symdel _sas_or_cas_op2;\n%end;\n\n%if %symexist(_tsdg_run_trigger) %then %do;\n   %symdel _tsdg_run_trigger;\n%end;\n\n%if %symexist(_tsdg_error_flag) %then %do;\n   %symdel _tsdg_error_flag;\n%end;\n\n%if %symexist(_tsdg_error_desc) %then %do;\n   %symdel _tsdg_error_desc;\n%end;\n\n%if %symexist(_current_uuid_) %then %do;\n   %symdel _current_uuid_;\n%end;\n\n%if %symexist(deviceArgumentString) %then %do;\n   %symdel deviceArgumentString;\n%end;\n\n%if %symexist(inputCaslib) %then %do;\n   %symdel inputCaslib;\n%end;\n\n%if %symexist(modelCaslib) %then %do;\n   %symdel modelCaslib;\n%end;\n\n%if %symexist(outputCaslib) %then %do;\n   %symdel outputCaslib;\n%end;\n\n%sysmacdelete _create_error_flag;\n%sysmacdelete _create_runtime_trigger;\n%sysmacdelete _env_cas_checkSession;\n%sysmacdelete _sas_or_cas;\n%sysmacdelete _cas_table_exists;\n%sysmacdelete _gpu_status_string_substitute;\n%sysmacdelete _usr_getNameCaslib;\n%sysmacdelete _tsdg_create_centroids_table;\n%sysmacdelete _tsdg_execution_code;\n"}}